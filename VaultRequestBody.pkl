//===----------------------------------------------------------------------===//
//  Copyright (c) 2025 Javier Cuesta
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//===----------------------------------------------------------------------===//
module VaultRequestBody

import "@openapi/Schema.pkl"

createToken = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["display_name"] {
      type =  "string"
      description = "Name to associate with this token"
    }
    ["entity_alias"] {
      type = "string"
      description = "Name of the entity alias to associate with this token"
    }
    ["explicit_max_ttl"] {
      type = "string"
      description = "Explicit Max TTL of this token"
    }
    ["id"] {
      type = "string"
      description = "Value for the token"
    }
    ["meta"] {
      type = "object"
      description = "Arbitrary key=value metadata to associate with the token"
      format = "kvpairs"
    }
    ["no_default_policy"] {
      type = "boolean"
      description = "Do not include default policy for this token"
    }
    ["no_parent"] {
      type = "boolean"
      description = "Create the token with no parent"
    }
    ["num_uses"] {
      type = "integer"
      description = "Max number of uses for this token"
    }
    ["period"] {
      type = "string"
      description = "Renew period"
    }
    ["policies"] {
      type = "array"
      description = "A list of policies for the token. This must be a subset of the policies belonging to the token making the request, unless the calling token is root or contains sudo capabilities to auth/token/create. If not specified, defaults to all the policies of the calling token."
      items = new Schema {
        type = "string"
      }
    }
    ["renewable"] {
      type = "boolean"
      description = "Allow token to be renewed past its initial TTL up to system/mount maximum TTL"
      default = true
    }
    ["ttl"] {
      type = "string"
      description = "Time to live for this token"
    }
    ["type"] {
      type = "string"
      description = "Token type"
      enum {
        "batch"
        "service"
        "default"
        "default-service"
        "default-batch"
      }
    }
  }
}

tokenLookup = (Schema.PropertySchema) {
  type = "object"
  required {
    "accessor"
    "creation_time"
    "creation_ttl"
    "display_name"
    "id"
    "num_uses"
    "orphan"
    "path"
    "policies"
    "renewable"
    "ttl"
    "type"
  }
  properties {
    ["accessor"] {
      type =  "string"
    }
    ["creation_time"] {
      type = "integer"
      description = "creation time in unix time stamp"
    }
    ["creation_ttl"] {
      type = "integer"
    }
    ["display_name"] {
      type =  "string"
      description = "Name to associate with this token"
    }
    ["entity_id"] {
      type = "string"
      description = "Name of the entity id to associate with this token"
    }
    ["expire_time"] {
      type = "string"
      format = "date-time"
      description = "Optional expire time date in string format."
    }
    ["explicit_max_ttl"] {
      type = "integer"
    }
    ["id"] {
      type = "string"
      description = "Value for the token"
    }
    ["issue_time"] {
      type = "string"
      format = "date-time"
      description = "issue time date in string format"
    }
    ["meta"] {
      type = "object"
      description = "Arbitrary key=value metadata to associate with the token"
      format = "kvpairs"
      additionalProperties {
        type = "string"
      }
    }
    ["num_uses"] {
      type = "integer"
      description = "Max number of uses for this token"
    }
    ["orphan"] {
      type = "boolean"
    }
    ["path"] {
      type = "string"
    }
    ["policies"] {
      type = "array"
      description = "A list of policies for the token."
      items = new Schema {
        type = "string"
      }
    }
    ["renewable"] {
      type = "boolean"
      description = "Allow token to be renewed past its initial TTL up to system/mount maximum TTL"
    }
    ["ttl"] {
      type = "integer"
      description = "Time to live for this token"
    }
    ["type"] {
      type = "string"
      description = "Token type"
      enum {
        "batch"
        "service"
        "default"
        "default-service"
        "default-batch"
      }
    }
  }
}

createTokenRole = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["allowed_policies"] {
      type = "array"
      description = #"If set, tokens can be created with any subset of the policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy names. If at creation time no_default_policy is not set and "default" is not contained in disallowed_policies or glob matched in disallowed_policies_glob, the "default" policy will be added to the created token automatically."#
      items = new Schema {
        type = "string"
      }
    }
    ["disallowed_policies"] {
      type = "array"
      description = #"If set, successful token creation via this role will require that no policies in the given list are requested. The parameter is a comma-delimited string of policy names. Adding "default" to this list will prevent "default" from being added automatically to created tokens."#
      items = new Schema {
        type = "string"
      }
    }
    ["allowed_policies_glob"] {
      type = "array"
      description = #"If set, tokens can be created with any subset of glob matched policies in this list, rather than the normal semantics of tokens being a subset of the calling token's policies. The parameter is a comma-delimited string of policy name globs. If at creation time no_default_policy is not set and "default" is not contained in disallowed_policies or glob matched in disallowed_policies_glob, the "default" policy will be added to the created token automatically. If combined with allowed_policies policies need to only match one of the two lists to be permitted. Note that unlike allowed_policies the policies listed in allowed_policies_glob will not be added to the token when no policies are specified in the call to /auth/token/create/:role_name."#
      items = new Schema {
        type = "string"
      }
    }
    ["disallowed_policies_glob"] {
      type = "array"
      description = #"If set, successful token creation via this role will require that no requested policies glob match any of policies in this list. The parameter is a comma-delimited string of policy name globs. Adding any glob that matches "default" to this list will prevent "default" from being added automatically to created tokens. If combined with disallowed_policies policies need to only match one of the two lists to be blocked."#
      items = new Schema {
        type = "string"
      }
    }
    ["orphan"] {
      type = "boolean"
      description = "If true, tokens created against this policy will be orphan tokens (they will have no parent). As such, they will not be automatically revoked by the revocation of any other token."
    }
    ["renewable"] {
      type = "boolean"
      description = "Set to false to disable the ability of the token to be renewed past its initial TTL. Setting the value to true will allow the token to be renewable up to the system/mount maximum TTL."
    }
    ["path_suffix"] {
      type = "string"
      description = #" If set, tokens created against this role will have the given suffix as part of their path in addition to the role name. This can be useful in certain scenarios, such as keeping the same role name in the future but revoking all tokens created against it before some point in time. The suffix can be changed, allowing new callers to have the new suffix as part of their path, and then tokens with the old suffix can be revoked via /sys/leases/revoke-prefix."#
    }
    ["allowed_entity_aliases"] {
      type = "array"
      description = #"String or JSON list of allowed entity aliases. If set, specifies the entity aliases which are allowed to be used during token generation. This field supports globbing. Note that allowed_entity_aliases is not case sensitive."#
      items = new Schema {
        type = "string"
      }
    }
    ["token_bound_cidrs"] {
      type = "array"
      description = "List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well."
      items = new Schema {
        type = "string"
      }
    }
    ["token_explicit_max_ttl"] {
      type = "string"
      description = "If set, will encode an explicit max TTL onto the token. This is a hard cap even if token_ttl and token_max_ttl would otherwise allow a renewal."
    }
    ["token_no_default_policy"] {
      type = "boolean"
      description = "If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in token_policies."
    }
    ["token_num_uses"] {
      type = "integer"
      description = "The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0."
    }
    ["token_period"] {
      type = "string"
      description = "The maximum allowed period value when a periodic token is requested from this role."
    }
    ["token_type"] {
      type = "string"
      description = #"The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time. For machine based authentication cases, you should use batch type tokens."#
      enum {
        "batch"
        "service"
        "default"
        "default-service"
        "default-batch"
      }
    }
  }
}

/// Response body when reading token role
tokenRole = (createTokenRole) {
  properties = (createTokenRole.properties) {
    ["name"] {
      type = "string"
      description = "The name of the token role."
    }
    ["token_explicit_max_ttl"] {
      type = "integer"
      description = "If set, will encode an explicit max TTL onto the token. This is a hard cap even if token_ttl and token_max_ttl would otherwise allow a renewal."
    }
    ["token_period"] {
      type = "integer"
      description = "The maximum allowed period value when a periodic token is requested from this role."
    }
  }
  required {
    "name"
  }
}

tokenCommon = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["token_bound_cidrs"] {
      type = "array"
      description = "List of CIDR blocks; if set, specifies blocks of IP addresses which can authenticate successfully, and ties the resulting token to these blocks as well."
      items = new Schema {
        type = "string"
      }
    }
    ["token_explicit_max_ttl"] {
      type = "string"
      description = "If set, will encode an explicit max TTL onto the token. This is a hard cap even if `token_ttl` and `token_max_ttl` would otherwise allow a renewal."
    }
    ["token_no_default_policy"] {
      type = "boolean"
      description = "If set, the default policy will not be set on generated tokens; otherwise it will be added to the policies set in `token_policies`."
    }
    ["token_num_uses"] {
      type = "integer"
      description = "The maximum number of times a generated token may be used (within its lifetime); 0 means unlimited. If you require the token to have the ability to create child tokens, you will need to set this value to 0."
    }
    ["token_period"] {
      type = "string"
      description = "The maximum allowed period value when a periodic token is requested from this role."
    }
    ["token_type"] {
      type = "string"
      description = #"The type of token that should be generated. Can be service, batch, or default to use the mount's tuned default (which unless changed will be service tokens). For token store roles, there are two additional possibilities: default-service and default-batch which specify the type to return unless the client requests a different type at generation time. For machine based authentication cases, you should use batch type tokens."#
      enum {
        "batch"
        "service"
        "default"
        "default-service"
        "default-batch"
      }
    }
  }
}

createAppRole = (tokenCommon) {
  properties {
    ["token_ttl"] {
      type = "string"
      description = "The incremental lifetime for generated tokens. This current value of this will be referenced at renewal time."
    }
    ["token_max_ttl"] {
      type = "string"
      description = "The maximum lifetime for generated tokens. This current value of this will be referenced at renewal time."
    }
    ["token_policies"] {
      type = "array"
      description = "List of token policies to encode onto generated tokens. Depending on the auth method, this list may be supplemented by user/group/other values."
      items = new Schema {
        type = "string"
      }
    }

    ["bind_secret_id"] {
      type = "boolean"
      description = "Require `secret_id` to be presented when logging in using this AppRole."
    }
    ["secret_id_bound_cidrs"] {
      type = "array"
      description = "Comma-separated string or list of CIDR blocks; if set, specifies blocks of IP addresses which can perform the login operation."
      items = new Schema {
        type = "string"
      }
    }
    ["secret_id_num_uses"] {
      type = "integer"
      description = "Number of times any particular SecretID can be used to fetch a token from this AppRole, after which the SecretID by default will expire. A value of zero will allow unlimited uses. However, this option may be overridden by the request's `num_uses` field when generating a SecretID."
    }
    ["secret_id_ttl"] {
      type = "string"
      description = "Duration in either an integer number of seconds (3600) or an integer time unit (60m) after which by default any SecretID expires. A value of zero will allow the SecretID to not expire. However, this option may be overridden by the request's `ttl` field when generating a SecretID."
    }
    ["local_secret_ids"] {
      type = "boolean"
      description = "If set, the secret IDs generated using this role will be cluster local. This can only be set during role creation and once set, it can't be reset later."
    }
  }
}

// --- KV Secret Engine ---------------------

kvSecretConfig = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["max_versions"] {
      type = "integer"
      description = "The number of versions to keep per key. This value applies to all keys, but a key's metadata setting can overwrite this value. Once a key has more than the configured allowed versions, the oldest version will be permanently deleted. When 0 is used or the value is unset, Vault will keep 10 versions."
    }
    ["cas_required"] {
      type = "boolean"
      description = "If true all keys will require the Compare-And-Swap (CAS) parameter to be set on all write requests."
      default = "false"
    }
    ["delete_version_after"] {
      type = "string"
      description = " If set, specifies the length of time before a version is deleted. Accepts Vault's duration format strings."
    }
  }
}

kvSecret = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["options"] {
      type = "object"
      properties {
        ["cas"] {
          type = "integer"
          description = "Compare-And-Swap (CAS)"
        }
      }
    }
    ["data"] {
      type = "object"
    }
  }
  required {
    "data"
  }
}

kvMetadata = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["created_time"] {
      type = "string"
      format = "date-time"
    }
    ["custom_metadata"] {
      type = "object"
      format = "kvpairs"
      additionalProperties {
        type = "string"
      }
    }
    ["deletion_time"] = new {
      oneOf {
        new Schema {
          type = "string"
          format = "date-time"
        }
        new Schema {
          type = "string"
        }
      }
    }
    ["destroyed"] {
      type = "boolean"
    }
    ["version"] {
      type = "integer"
    }
  }
  required {
    "created_time"
    "destroyed"
    "version"
  }
}

secretVersions = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["versions"] {
      type = "array"
      items = new Schema {
        type = "string"
      }
    }
  }
  required {
    "versions"
  }
}

kvStoreMetadata = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["cas_required"] {
      type = "boolean"
    }
    ["custom_metadata"] {
      type = "object"
      format = "kvpairs"
      additionalProperties {
        type = "string"
      }
    }
    ["delete_version_after"] {
      description = "Set the delete_version_after value to a duration to specify the deletion_time for all new versions written to this key. If not set, the backend's delete_version_after will be used. If the value is greater than the backend's delete_version_after, the backend's delete_version_after will be used. 0s is equivalent to not set"
      type = "string"
      default = "0s"
    }
    ["max_versions"] {
      type = "integer"
    }
  }
  required {
    "cas_required"
    "delete_version_after"
    "max_versions"
  }
}

// Transit Engine --------------------------------------

createEncryptionKeyCore = (Schema.PropertySchema) {
  type = "object"
  required {
    "derived"
    "exportable"
    "allow_plaintext_backup"
    "type"
    "auto_rotate_period"
  }
  properties {
    ["derived"] {
      type = "boolean"
      description = "Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this named key must provide a context which is used for key derivation."
    }
    ["exportable"] {
      type = "boolean"
      description = "Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled."
    }
    ["allow_plaintext_backup"] {
      type = "boolean"
      description = "If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled."
    }
    ["type"] = encryptionKeyType
    ["auto_rotate_period"] {
      type = "string"
      description = "The period at which this key should be rotated automatically. Setting this to '0' (the default) will disable automatic key rotation. This value cannot be shorter than one hour."
    }
  }
}

createEncryptionKey = (createEncryptionKeyCore) {
  type = "object"
  properties {
    ["convergent_encryption"] {
      type = "boolean"
      description = """
      if enabled, the key will support convergent encryption, where the same plaintext creates the same ciphertext. This requires `derived` to be set to true. 
      When enabled, each encryption(`/decryption/rewrap/datakey`) operation will derive a nonce value rather than randomly generate it.
      """
    }
    ["key_size"] {
      type = "integer"
      description = "The key size in bytes for algorithms that allow variable key sizes. Currently only applicable to HMAC, where it must be between 32 and 512 bytes."
    }
  }
}

importEncryptionKey = (createEncryptionKeyCore) {
  type = "object"
  properties {
    ["ciphertext"] {
      type = "string"
      description = """
      base64-encoded string that contains two values: an ephemeral 256-bit AES key wrapped using the wrapping key returned by OpenBao and the encryption of the import key material under the provided AES key.
      The wrapped AES key should be the first 512 bytes of the ciphertext, and the encrypted key material should be the remaining bytes.
      See the BYOK section of the Transit secrets engine documentation for more information on constructing the ciphertext. If public_key is set, this field is not required.
      """
    }
    ["hash_function"] = hashFunctions
    ["public_key"] {
      type = "string"
      description = "A plaintext PEM public key to be imported. This limits the operations available under this key to verification and encryption, depending on the key type and algorithm, as no private key is available."
    }
    ["context"] {
      type = "string"
      description = "A base64-encoded string providing a context for key derivation. Required if derived is set to true."
    }

  }
}

importVersionedEncryptionKey = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["ciphertext"] {
      type = "string"
      description = """
      base64-encoded string that contains two values: an ephemeral 256-bit AES key wrapped using the wrapping key returned by OpenBao and the encryption of the import key material under the provided AES key.
      The wrapped AES key should be the first 512 bytes of the ciphertext, and the encrypted key material should be the remaining bytes.
      See the BYOK section of the Transit secrets engine documentation for more information on constructing the ciphertext. If public_key is set, this field is not required.
      """
    }
    ["hash_function"] = hashFunctions
    ["public_key"] {
      type = "string"
      description = "A plaintext PEM public key to be imported. This limits the operations available under this key to verification and encryption, depending on the key type and algorithm, as no private key is available."
    }
    ["version"] {
      type = "integer"
      description = "Key version to be updated, if left empty, a new version will be created unless a private key is specified and the 'Latest' key is missing a private key."
    }
  }
}

exportKey = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["format"] {
      type = "string"
      description = """
      Specifies the format of the exported key. The empty string preserves existing behavior, 
      with format unique to each key type (base64 encoded raw keys for symmetric keys or Ed25519 keys, PKCS#1 for RSA private keys, SEC 1 for EC private keys, and PKIX format for RSA or EC public keys). 
      The raw format always returns a base64 encoded raw key (only applicable to symmetric keys and Ed25519 keys). 
      The der and pem formats always returns a PKIX (SubjectPublicKeyInfo) or PrivateKeyInfo encoded object for asymmetric keys.
      """
      enum {
        "base64"
        "raw"
        "der"
        "pem"
      }
    }
  }
}

encryptionKeyType = (Schema.PropertySchema) {
  type = "string"
  description = "Specifies the type of key to create. Defaults to aes256-gcm96"
  enum {
    "aes128-gcm96"
    "aes256-gcm96"
    "chacha20-poly1305"
    "xchacha20-poly1305"
    "ed25519"
    "ecdsa-p256"
    "ecdsa-p384"
    "ecdsa-p521"
    "rsa-2048"
    "rsa-3072"
    "rsa-4096"
    "hmac"
  }
}

hashFunctions = (Schema.PropertySchema) {
  type = "string"
  description = "The hash function used for the RSA-OAEP step of creating the ciphertext. Defaults to SHA256"
  enum {
    "SHA224"
    "SHA256"
    "SHA384"
    "SHA512"
  }
}

hashAlgorithms = (Schema.PropertySchema) {
  type = "string"
  description = """
  Hash Algorithms. Defaults to sha2-256.

  Important: In FIPS 140-2 mode, the following algorithms are not certified and thus should not be used: sha3-224, sha3-256, sha3-384, and sha3-512.
  """
  enum {
    "sha2-224"
    "sha2-256"
    "sha2-384"
    "sha2-512"
    "sha3-224"
    "sha3-256"
    "sha3-384"
    "sha3-512"
  }
}

signatureAlgorithms = (Schema.PropertySchema) {
  type = "string"
  description = "When using a RSA key, specifies the RSA signature algorithm to use for signature verification. Defaults to pss"
  enum {
    "pss"
    "pkcs1v15"
  }
}

extendedHashAlgorithmns = (hashAlgorithms) {
  enum {
    "none"
  }
}

generateHMAC = (Schema.PropertySchema) {
  type = "object"
  required {
    "input"
  }
  properties {
    ["algorithm"] = hashAlgorithms
    ["input"] {
      type = "string"
      description = "Specifies the base64 encoded input data. One of input or batch_input must be supplied."
    }
    ["key_version"] {
      type = "integer"
      description = "Specifies the version of the key to use for the operation. If not set, uses the latest version. Must be greater than or equal to the key's min_encryption_version, if set."
    }
    ["batch_input"] {
      type = "array"
      items = new Schema {
        type = "object"
        required {
          "input"
        }
        properties {
          ["input"] {
            type = "string"
            description = "Specifies the base64 encoded input data. One of input or batch_input must be supplied."
          }
          ["reference"] {
            type = "string"
            description = """
            A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input.
            """
          }
        }
      }
    }
  }
}

signData = (Schema.PropertySchema) {
  type = "object"
  required {
    "input"
  }
  properties {
    ["hash_algorithm"] = extendedHashAlgorithmns
    ["input"] {
      type = "string"
      description = "Specifies the base64 encoded input data. One of input or batch_input must be supplied."
    }
    ["batch_input"] {
      type = "array"
      items = new Schema {
        type = "object"
        required {
          "input"
        }
        properties {
          ["input"] {
            type = "string"
            description = "Specifies the base64 encoded input data. One of input or batch_input must be supplied."
          }
          ["hmac"] {
            type = "string"
          }
          ["signature"] {
            type = "string"
          }
          ["context"] {
            type = "string"
            description = "Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys."
          }
          ["reference"] {
            type = "string"
            description = """
            A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input.
            """
          }
        }
      }
    }
    ["context"] {
      type = "string"
      description = "Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys."
    }
    ["prehashed"] {
      type = "boolean"
      description = "Set to true when the input is already hashed. If the key type is rsa-2048, rsa-3072 or rsa-4096, then the algorithm used to hash the input should be indicated by the hash_algorithm parameter."
    }
    ["signature_algorithm"] = signatureAlgorithms
    ["marshaling_algorithm"] {
      type = "string"
      description = "Specifies the way in which the signature should be marshaled. This currently only applies to ECDSA keys. Defaults to asn1"
      enum {
        "asn1"
        "jws" // The version used by JWS (and thus for JWTs). Selecting this will also change the output encoding to URL-safe Base64 encoding instead of standard Base64-encoding.
      }
    }
    ["salt_length"] = new {
      oneOf {
        new Schema {
          type = "string"
          description = "Specifies the way in which the signature should be marshaled. This currently only applies to ECDSA keys. Defaults to asn1"
          enum {
            "auto"
            "hash"
          }
        }

        new Schema {
          type = "integer"
          description = "An integer between the minimum and the maximum permissible salt lengths for the given RSA key size."
        }
      }
    }
  }
}

rewrapData = (Schema.PropertySchema) {
  type = "object"
  required {
    "ciphertext"
  }
  properties {
    ["ciphertext"] {
      type = "string"
      description = "Specifies the ciphertext to re-encrypt."
    }
    ["key_version"] {
      type = "integer"
      description = "Specifies the version of the key to use for the operation. If not set, uses the latest version. Must be greater than or equal to the key's min_encryption_version, if set."
    }
    ["nonce"] {
      type = "string"
      description = "Specifies a base64 encoded nonce value used during encryption."
    }
    ["batch_input"] {
      type = "array"
      items = new Schema {
        type = "object"
        required {
          "ciphertext"
        }
        properties {
          ["ciphertext"] {
            type = "string"
            description = "Specifies the ciphertext to re-encrypt."
          }
          ["context"] {
            type = "string"
            description = "Base64 encoded context for key derivation. Required if key derivation is enabled; currently only available with ed25519 keys."
          }
          ["reference"] {
            type = "string"
            description = """
            A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input.
            """
          }
        }
      }
    }
    ["context"] {
      type = "string"
      description = "Specifies the base64 encoded context for key derivation. This is required if key derivation is enabled."
    }
  }
}

encryptionKey = (createEncryptionKeyCore) {
  type = "object"
  required {
    "keys"
    "latest_version"
    "min_decryption_version"
    "min_encryption_version"
    "name"
    "supports_encryption"
    "supports_decryption"
    "supports_derivation"
    "supports_signing"
  }
  properties {
    ["deletion_allowed"] {
      type = "boolean"
    }
    ["imported_key"] {
      type = "boolean"
    }
    ["kdf"] {
      type = "string"
    }
    ["keys"] {
      type = "object"
      description = "lists each version of the key, and the time that key was created as seconds since the Unix epoch"
      format = "kvpairs"
      additionalProperties {
        oneOf {
          encryptionAsymmetricKeyData
          new Schema {
            type = "integer"
          }
        }
      }
    }
    ["latest_version"] {
      type = "integer"
    }
    ["min_available_version"] {
      type = "integer"
    }
    ["min_decryption_version"] {
      type = "integer"
    }
    ["min_encryption_version"] {
      type = "integer"
    }
    ["name"] {
      type = "string"
    }
    ["soft_deleted"] {
      type = "boolean"
    }
    ["supports_decryption"] {
      type = "boolean"
    }
    ["supports_derivation"] {
      type = "boolean"
    }
    ["supports_encryption"] {
      type = "boolean"
    }
    ["supports_signing"] {
      type = "boolean"
    }
  }
}

encryptionAsymmetricKeyData = (Schema.PropertySchema) {
  type = "object"
  required {
    "creation_time"
    "name"
  }
  properties {
    ["certificate_chain"] {
      type = "string"
    }
    ["creation_time"] {
      type = "string"
      format = "date-time"
    }
    ["name"] {
      type = "string"
    }
    ["public_key"] {
      type = "string"
    }
  }
}

ecnryptionKeyConfig = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["min_decryption_version"] {
      type = "integer"
      description = """
      Specifies the minimum version of ciphertext allowed to be decrypted. Adjusting this as part of a key rotation policy can prevent old copies of ciphertext from being decrypted,
      should they fall into the wrong hands. For signatures, this value controls the minimum version of signature that can be verified against. 
      For HMACs, this controls the minimum version of a key allowed to be used as the key for verification.
      """
    }
    ["min_encryption_version"] {
      type = "integer"
      description = "Specifies the minimum version of the key that can be used to encrypt plaintext, sign payloads, or generate HMACs. Must be 0 (which will use the latest version) or a value greater or equal to `min_decryption_version`."
    }
    ["deletion_allowed"] {
      type = "boolean"
    }
    ["exportable"] {
      type = "boolean"
      description = "Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled."
    }
    ["allow_plaintext_backup"] {
      type = "boolean"
      description = "If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled."
    }
    ["auto_rotate_period"] {
      type = "string"
      description = "The period at which this key should be rotated automatically. Setting this to '0' (the default) will disable automatic key rotation. This value cannot be shorter than one hour."
    }
  }
}

encryptionData = (encryptionCoreData) {
  type = "object"
  required {
    "plaintext"
  }
  properties {
    ["plaintext"] {
      type = "string"
      description = "Specifies base64 encoded plaintext to be encoded."
    }
    ["key_version"] {
      type = "integer"
      description = "Specifies the version of the key to use for encryption. If not set, uses the latest version. Must be greater than or equal to the key's min_encryption_version, if set."
    }
    ["type"] = encryptionKeyType
    ["convergent_encryption"] {
      type = "string"
      description = """
      This parameter will only be used when a key is expected to be created. Whether to support convergent encryption. 
      This is only supported when using a key with key derivation enabled and will require all requests to carry both a context and 96-bit (12-byte) for AES and ChaCha20 or 192-bit (24-byte) for XChaCha20 nonce. 
      The given nonce will be used in place of a randomly generated nonce. As a result, when the same context and nonce are supplied, the same ciphertext is generated. 
      It is very important when using this mode that you ensure that all nonces are unique for a given context. Failing to do so will severely impact the ciphertext's security.
      """
    }
  }
}

decryptionData = (encryptionCoreData) {
  type = "object"
  required {
    "ciphertext"
  }
  properties {
    ["ciphertext"] {
      type = "string"
      description = "Specifies base64 encoded plaintext to be encoded."
    }
  }
}

encryptionCoreData = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["associated_data"] {
      type = "string"
      description = "Specifies base64 encoded associated data (also known as additional data or AAD) to also be authenticated with AEAD ciphers (aes128-gcm96, aes256-gcm, chacha20-poly1305, and xchacha20-poly1305)."
    }
    ["context"] {
      type = "string"
      description = "Specifies the base64 encoded context for key derivation. This is required if key derivation is enabled for this key."
    }
    ["nonce"] {
      type = "string"
      description = "Specifies the base64 encoded nonce value. The value must be exactly 96 bits (12 bytes) long and the user must ensure that for any given context (and thus, any given encryption key) this nonce value is never reused."
    }
    ["batch_input"] {
      type = "array"
      items = new Schema {
        type = "object"
        required {
          "plaintext"
        }
        properties {
          ["plaintext"] {
            type = "string"
            description = "Specifies base64 encoded plaintext to be encoded."
          }
          ["context"] {
            type = "string"
            description = "Specifies the base64 encoded context for key derivation. This is required if key derivation is enabled for this key."
          }
          ["reference"] {
            type = "string"
            description = "A user-supplied string that will be present in the reference field on the corresponding batch_results item in the response, to assist in understanding which result corresponds to a particular input."
          }
        }
      }
    }
    ["partial_failure_response_code"] {
      type = "integer"
      description = """
      Ordinarily, if a batch item fails to encrypt due to a bad input, but other batch items succeed, the HTTP response code is 400 (Bad Request). 
      Some applications may want to treat partial failures differently. Providing the parameter returns the given response code integer instead of a failed status code in this case. 
      If all values fail an error code is still returned. Be warned that some failures (such as failure to decrypt) could be indicative of a security breach and should not be ignored.
      """
    }
  }
}

generateKeyData = (Schema.PropertySchema) {
  type = "object"
  properties {
    ["associated_data"] {
      type = "string"
      description = "Specifies base64 encoded associated data (also known as additional data or AAD) to also be authenticated with AEAD ciphers (aes128-gcm96, aes256-gcm, chacha20-poly1305, and xchacha20-poly1305)."
    }
    ["context"] {
      type = "string"
      description = "Specifies the base64 encoded context for key derivation. This is required if key derivation is enabled for this key."
    }
    ["nonce"] {
      type = "string"
      description = "Specifies the base64 encoded nonce value. The value must be exactly 96 bits (12 bytes) long and the user must ensure that for any given context (and thus, any given encryption key) this nonce value is never reused."
    }
    ["bits"] {
      type = "integer"
      description = "Specifies the number of bits in the desired key. Can be 128, 256, or 512. Defaults to 256"
    }
  }
}