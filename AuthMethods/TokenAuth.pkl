//===----------------------------------------------------------------------===//
//  Copyright (c) 2025 Javier Cuesta
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//===----------------------------------------------------------------------===//

/// The token auth method is built-in and automatically available at `/auth/token`. It allows users to authenticate using a token, as well to create new tokens, revoke secrets by token, and more.
/// When any other auth method returns an identity, Vault core invokes the token method to create a new unique token for that identity.
/// The token store can also be used to bypass any other auth method: you can create tokens directly, as well as perform a variety of other operations on tokens such as renewal and revocation.
/// [Token concepts](https://developer.hashicorp.com/vault/docs/concepts/tokens)
/// [API](https://developer.hashicorp.com/vault/api-docs/auth/token)
module TokenAuth

amends "@openapi/Document.pkl"
import "@openapi/PathItem.pkl"
import "@openapi/Reference.pkl"
import "@openapi/Schema.pkl"
import "@openapi/HTTPResponse.pkl"

paths {
  ["/auth/token/create"] {
    description = "The token create path is used to create new tokens."
    parameters {
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
      new Reference {
        `$ref` = "#/components/parameters/WrapTTLHeader"
      }
    }
    post {
      summary = "The token create path is used to create new tokens."
      operationId = "token-create"
      tags {
        "auth"
      }
      requestBody {
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/TokenCreateRequest"
            }
          }
        }
        required = true
      }
      responses {
        ["200"] {
          description = "OK"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultApiResponse"
              }
            }
          }
        }
        [HTTPResponse.BadRequest] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
  }

  ["/auth/token/renew"] {
    description = "This endpoint will renew the given token and prevent expiration."
    parameters {
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
      new Reference {
        `$ref` = "#/components/parameters/WrapTTLHeader"
      }
    }
    post {
      summary = "This endpoint will renew the given token and prevent expiration."
      operationId = "token-renew"
      tags {
        "auth"
      }
      requestBody {
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/TokenRenewRequest"
            }
          }
        }
        required = true
      }
      responses {
        ["200"] {
          description = "OK"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultApiResponse"
              }
            }
          }
        }
        [HTTPResponse.BadRequest] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
  }

  ["/auth/token/renew-self"] {
    description = "Renews a lease associated with the calling token. This is used to prevent the expiration of a token, and the automatic revocation of it. Token renewal is possible only if there is a lease associated with it."
    parameters {
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
      new Reference {
        `$ref` = "#/components/parameters/WrapTTLHeader"
      }
    }
    post {
      summary = "Renews a lease associated with the calling token."
      operationId = "token-renew-self"
      tags {
        "auth"
      }
      requestBody {
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/TokenRenewSelfRequest"
            }
          }
        }
        required = true
      }
      responses {
        ["200"] {
          description = "OK"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultApiResponse"
              }
            }
          }
        }
        [HTTPResponse.BadRequest] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
  }

  ["/auth/token/renew-accessor"] {
    description = "Renews a lease associated with a token using its accessor. This is used to prevent the expiration of a token, and the automatic revocation of it. Token renewal is possible only if there is a lease associated with it."
    parameters {
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
      new Reference {
        `$ref` = "#/components/parameters/WrapTTLHeader"
      }
    }
    post {
      summary = "Renews a lease associated with a token using its accessor."
      operationId = "token-renew-accessor"
      tags {
        "auth"
      }
      requestBody {
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/TokenRenewAccessorRequest"
            }
          }
        }
        required = true
      }
      responses {
        ["200"] {
          description = "OK"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultApiResponse"
              }
            }
          }
        }
        [HTTPResponse.BadRequest] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
  }

  ["/auth/token/revoke"] {
    description = "Revokes a token and all child tokens. When the token is revoked, all dynamic secrets generated with it are also revoked."
    parameters {
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
      new Reference {
        `$ref` = "#/components/parameters/WrapTTLHeader"
      }
    }
    post {
      summary = "Revokes a token and all child tokens. When the token is revoked, all dynamic secrets generated with it are also revoked."
      operationId = "token-revoke"
      tags {
        "auth"
      }
      requestBody {
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/TokenRevokeRequest"
            }
          }
        }
        required = true
      }
      responses {
        ["200"] {
          description = "OK"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultApiResponse"
              }
            }
          }
        }
        [HTTPResponse.BadRequest] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
  }
}

components {
  schemas {
    ["TokenCreateRequest"] {
      type = "object"
      properties {
        ["display_name"] {
          type =  "string"
          description = "Name to associate with this token"
        }
        ["entity_alias"] {
          type = "string"
          description = "Name of the entity alias to associate with this token"
        }
        ["explicit_max_ttl"] {
          type = "string"
          description = "Explicit Max TTL of this token"
        }
        ["id"] {
          type = "string"
          description = "Value for the token"
        }
        ["meta"] {
          type = "object"
          description = "Arbitrary key=value metadata to associate with the token"
          format = "kvpairs"
        }
        ["no_default_policy"] {
          type = "boolean"
          description = "Do not include default policy for this token"
        }
        ["no_parent"] {
          type = "boolean"
          description = "Create the token with no parent"
        }
        ["num_uses"] {
          type = "integer"
          description = "Max number of uses for this token"
        }
        ["period"] {
          type = "string"
          description = "Renew period"
        }
        ["policies"] {
          type = "array"
          description = "A list of policies for the token. This must be a subset of the policies belonging to the token making the request, unless the calling token is root or contains sudo capabilities to auth/token/create. If not specified, defaults to all the policies of the calling token."
          items = new Schema {
            type = "string"
          }
        }
        ["renewable"] {
          type = "boolean"
          description = "Allow token to be renewed past its initial TTL up to system/mount maximum TTL"
          default = true
        }
        ["ttl"] {
          type = "string"
          description = "Time to live for this token"
        }
        ["type"] {
          type = "string"
          description = "Token type"
        }
      }
    }

    ["TokenRenewRequest"] {
      type = "object"
      properties {
        ["token"] {
          type = "string"
          description = "Token to renew (request body)"
        }
        ["increment"] {
          type = "string"
          description = "The desired increment in seconds to the token expiration"
          format = "duration"
          default = "0"
        }
      }
      required {
        "token"
      }
    }

    ["TokenRenewSelfRequest"] {
      type = "object"
      properties {
        ["increment"] {
          type = "string"
          description = "The desired increment in seconds to the token expiration"
          format = "duration"
          default = "0"
        }
      }
    }

    ["TokenRenewAccessorRequest"] {
      type = "object"
      properties {
        ["accessor"] {
          type = "string"
          description = "Accessor associated with the token to renew."
        }
        ["increment"] {
          type = "string"
          description = "The desired increment in seconds to the token expiration"
          format = "duration"
          default = "0"
        }
      }
      required {
        "accessor"
      }
    }

    ["TokenRevokeRequest"] {
      type = "object"
      properties {
        ["token"] {
          type = "string"
          description = "Token to renew (request body)"
        }
      }
      required {
        "token"
      }
    }
  }
}