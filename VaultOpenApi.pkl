//===----------------------------------------------------------------------===//
//  Copyright (c) 2025 Javier Cuesta
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//===----------------------------------------------------------------------===//

amends "@openapi/Document.pkl"

import "@openapi/Schema.pkl"
import "@openapi/HTTPResponse.pkl"

import "TokenAuth.pkl" as TokenAuth
import "AppRoleAuth.pkl" as AppRoleAuth
import "CommonSysPaths.pkl"
import "KeyValueEngine.pkl" as KeyValueEngine
import "PostgresDatabaseConfiguration.pkl" as PostgresDatabaseConfiguration

info {
  title = "Vault Courier"
  description = "API client for Hashicorp Vault and OpenBao"
  version = "0.0.1"
  license {
    name = "Apache License 2.0"
  }
}

servers {
  new { 
    url = "http://127.0.0.1:8200/v1" 
  }
}

paths {
  ...TokenAuth.paths

  ["/sys/policies/acl/{name}"] {
    description = "Read, Modify, or Delete an access control policy."
    parameters {
      new {
        name = "name"
        description = "The name of the policy. Example: \"ops\""
        `in` = "path"
        schema {
          type = "string"
        }
        required = true
      }
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
    }
    post {
      summary = "Add a new or update an existing ACL policy."
      operationId = "policies-write-acl-policy"
      tags {
        "system"
      }
      requestBody {
        required = true
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/PoliciesWriteAclPolicyRequest"
            }
          }
        }
      }
      responses {
        ["204"] {
          description = "NoContent"
        }
      }
    }
  }
  // https://developer.hashicorp.com/vault/api-docs/system/mounts
  ["/sys/mounts/{path}"] {
    description = "Mount a new backend at a new path. Example: KV2"
    parameters {
      new {
        name = "path"
        description = "The path to mount to. Example: \"aws/east\""
        `in` = "path"
        schema {
          type = "string"
        }
        required = true
      }
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
    }
    post {
      summary = "Enable a new secrets engine at the given path."
      operationId = "mounts-enable-secrets-engine"
      tags {
        "system"
      }
      requestBody {
        required = true
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/MountsEnableSecretsEngineRequest"
            }
          }
        }
      }
      responses {
        ["204"] {
          description = "NoContent"
        }
        ["400"] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
  }

  // https://developer.hashicorp.com/vault/api-docs/system/auth#enable-auth-method
  ["/sys/auth/{path}"] {
    description = "Enable a new credential backend with a name."
    parameters {
      new {
        name = "path"
        description = "The path to mount to. Cannot be delimited. Example: \"user\""
        `in` = "path"
        schema {
          type = "string"
        }
        required = true
      }
      new Reference {
        `$ref` = "#/components/parameters/VaultTokenHeader"
      }
    }
    get {
      summary = "Reads auth method."
      description = "This endpoints returns the configuration of the auth method at the given path. This endpoint requires sudo capability on the final path, but the same functionality can be achieved without sudo via `sys/mounts/auth/[auth-path]`."
      operationId = "auth-read-method"
      tags {
        "system"
      }
      responses {
        ["200"] {
          description = "OK"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/ReadAuthMethodResponse"
              }
            }
          }
        }
        ["400"] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
    post {
      summary = "Enables a new auth method."
      description = "After enabling, the auth method can be accessed and configured via the auth path specified as part of the URL. This auth path will be nested under the auth prefix.\n\nFor example, enable the \"foo\" auth method will make it accessible at `/auth/foo`."
      operationId = "auth-enable-method"
      tags {
        "system"
      }
      requestBody {
        required = true
        content {
          ["application/json"] {
            schema = new Reference {
              `$ref` = "#/components/schemas/AuthEnableMethodRequest"
            }
          }
        }
      }
      responses {
        ["204"] {
          description = "NoContent"
        }
        ["400"] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
    `delete` {
      summary = "Disables the auth method at the given auth path."
      description = "This endpoint disables the auth method at the given auth path. This endpoint requires sudo capability in addition to any path-specific capabilities."
      operationId = "auth-disable-method"
      tags {
        "system"
      }
      responses {
        ["204"] {
          description = "NoContent"
        }
        ["400"] {
          description = "BadRequest"
          content {
            ["application/json"] {
              schema = new Reference {
                `$ref` = "#/components/schemas/VaultErrorsResponse"
              }
            }
          }
        }
      }
    }
  }

  ...AppRoleAuth.paths

  ...KeyValueEngine.paths

  ...CommonSysPaths.paths

  ...PostgresDatabaseConfiguration.paths
}

components {
  parameters {
    ["VaultTokenHeader"] {
      name = "X-Vault-Token"
      description = "Vault Token required for authentication"
      `in` = "header"
      schema = new Schema {
        type = "string"
      }
    }
    ["WrapTTLHeader"] {
      name = "X-Vault-Wrap-TTL"
      description = "Use the X-Vault-Wrap-TTL header with any Vault API call where you want to wrap the response."
      `in` = "header"
      schema {
        type = "string"
      }
    }
  }
  schemas {
    ["TokenCreateRequest"] {
      type = "object"
      properties {
        ["display_name"] {
          type =  "string"
          description = "Name to associate with this token"
        }
        ["entity_alias"] {
          type = "string"
          description = "Name of the entity alias to associate with this token"
        }
        ["explicit_max_ttl"] {
          type = "string"
          description = "Explicit Max TTL of this token"
        }
        ["id"] {
          type = "string"
          description = "Value for the token"
        }
        ["meta"] {
          type = "object"
          description = "Arbitrary key=value metadata to associate with the token"
          format = "kvpairs"
        }
        ["no_default_policy"] {
          type = "boolean"
          description = "Do not include default policy for this token"
        }
        ["no_parent"] {
          type = "boolean"
          description = "Create the token with no parent"
        }
        ["num_uses"] {
          type = "integer"
          description = "Max number of uses for this token"
        }
        ["period"] {
          type = "string"
          description = "Renew period"
        }
        ["policies"] {
          type = "array"
          description = "List of policies for the token"
          items = new Schema {
            type = "string"
          }
        }
        ["renewable"] {
          type = "boolean"
          description = "Allow token to be renewed past its initial TTL up to system/mount maximum TTL"
          default = true
        }
        ["ttl"] {
          type = "string"
          description = "Time to live for this token"
        }
        ["type"] {
          type = "string"
          description = "Token type"
        }
      }
    }
    ["TokenCreateResponse"] {
      type = "object"
      properties {
        ["request_id"] {
          type = "string"
          description = "the id of the request associated with this response"
        }
        ["renewable"] {
          type = "boolean"
        }
        ["mount_type"] {
          type = "string"
        }
        ["auth"] {
          type = "object"
          properties {
            ["client_token"] {
              type = "string"
              description = "the token value"
            }
            ["accessor"] {
              type = "string"
            }
            ["token_policies"] {
              type = "array"
              description = "List of policies attached to the token"
              items = new Schema {
                type = "string"
              }
            }
            ["lease_duration"] {
              type = "integer"
            }
            ["token_type"] {
              type = "string"
            }
            ["orphan"] {
              type = "boolean"
            }
            ["num_uses"] {
              type = "integer"
            }
          }
          required {
            "client_token"
            "accessor"
            "token_policies"
            "lease_duration"
            "token_type"
            "orphan"
            "num_uses"
          }
        }
      }
      required {
        "request_id"
        "mount_type"
        "renewable"
        "auth"
      }
    }
    
    ["PoliciesWriteAclPolicyRequest"] {
      type = "object"
      properties {
        ["policy"] {
          type = "string"
          description = "The rules of the policy."
        }
      }
    }

    ["MountsEnableSecretsEngineRequest"] {
      type = "object"
      properties {
          ["config"] {
            type = "object"
            description = "Configuration for this mount, such as default_lease_ttl and max_lease_ttl."
            format = "map"
          }
          ["description"] {
            type = "string"
            description = "User-friendly description for this mount."
          }
          ["external_entropy_access"] {
            type = "boolean"
            description = "Whether to give the mount access to Vault's external entropy."
            default = false
          }
          ["local"] {
            type = "boolean"
            description = "Mark the mount as a local mount, which is not replicated and is unaffected by replication."
            default = false
          }
          ["options"] {
            type = "object"
            description = "The options to pass into the backend. Should be a json object with string keys and values."
            format = "kvpairs"
          }
          ["plugin_name"] {
            type = "string"
            description = "Name of the plugin to mount based from the name registered in the plugin catalog."
          }
          ["plugin_version"] {
            type = "string"
            description = "The semantic version of the plugin to use, or image tag if oci_image is provided."
          }
          ["seal_wrap"] {
            type = "boolean"
            description = "Whether to turn on seal wrapping for the mount."
            default = false
          }
          ["type"] {
            type = "string"
            description = "The type of the backend. Example: \"passthrough\""
          }
      }
    }

    ["AuthEnableMethodRequest"] {
      type = "object"
      properties {
        ["config"] {
          type = "object"
          description = "Configuration for this mount, such as plugin_name."
          format = "map"
        }
        ["description"] {
          type = "string"
          description = "User-friendly description for this credential backend."
        }
        ["local"] {
          type = "boolean"
          description = "Mark the mount as a local mount, which is not replicated and is unaffected by replication."
          default = false
        }
        ["options"] {
          type = "object"
          description = "The options to pass into the backend. Should be a json object with string keys and values."
          format = "kvpairs"
        }
        ["seal_wrap"] {
          type = "boolean"
          description = "Whether to turn on seal wrapping for the mount."
          default = false
        }
        ["type"] {
          type = "string"
          description = "The type of the backend. Example: \"userpass\""
        }
      }
    }

    ["ReadAuthMethodResponse"] {
      type = "object"
      properties {
        ["request_id"] {
          type = "string"
          description = "the id of the request associated with this response"
        }
        ["data"] {
          type = "object"
          properties {
            ["accessor"] {
              type = "string"
            }
            ["external_entropy_access"] {
              type = "boolean"
            }
            ["local"] {
              type = "boolean"
            }
            ["config"] {
              type = "object"
              description = "Configuration for this mount, such as plugin_name."
              format = "kvpairs"
            }
            ["options"] {
              type = "object"
              description = "The options to pass into the backend"
              format = "kvpairs"
            }
            ["seal_wrap"] {
              type = "boolean"
              description = "Whether to turn on seal wrapping for the mount."
            }
            ["description"] {
              type = "string"
            }
            ["type"] {
              type = "string"
              description = "The type of the backend. Example: \"userpass\""
            }
          }
          required {
            "type"
            "config"
          }
        }
        ["mount_type"] {
          type = "string"
        }
      }
      required {
        "data"
      }
    }

    ...CommonSysPaths.components.schemas

    ...AppRoleAuth.components.schemas

    ...PostgresDatabaseConfiguration.components.schemas

    ["VaultErrorsResponse"] {
      type = "object"
      properties {
        ["errors"] {
          type = "array"
          description = "List of errors"
          items = new Schema {
            type = "string"
          }
        }
      }
    }
  }
}
